mixin help-button(icon, text)
  span.btn.btn-xs(class=attributes.class)
    i.fa(class=icon)
    |  #{text}

.row(ng-controller="TreebankHelpCtrl")
  .col-md-8.col-lg-7
    h1 Welcome
    p This quick introduction to PML-TQ is semi-automatically generated and covers the most basic topics only.
    h2 Using This Interface
    table.table.table-without-borders
      tr
        td
          +help-button('fa-search', 'Query')(class='btn-primary')
        td Sends the query to the server and displays the results
      tr
        td
          +help-button('fa-filter', 'w/o Filters')(class='btn-default')
        td Submits the query without any <a href="#output-filters">output filters</a> (see below).
      tr
        td
          +help-button('fa-sun-o', 'Visualize')(class='btn-default')
        td Shows visualization of the query
      tr
        td
          +help-button('fa-question', 'Suggest')(class='btn-default')
        td It is also possible to add result nodes to the query: run some simple query to display a tree from the treebank.
          | Then mark (by clicking) one or more related nodes in the result tree and press Suggest;
          | A PML-TQ query based on the marked nodes will be suggested and displayed in a dialog where you can exclude/include its parts and then
          | paste it directly to the query text box.
      tr
        td
          code
            b timeout
        td Complex or low-selective queries may take a few seconds to evaluate; the timeout option specifies maximum time the server should spend trying to evaluate the query.

    h2 Annotation Schema of {{treebank.title}}
    p This treebank consists of the following <b>annotation layer(s)</b> and <b>node type(s)</b>:
    ul.layers
      li(ng-repeat="schema in metadata.schemas") Layer <strong><code>{{schema}}</code></strong> consists of node types:<br>
        strong.text-mono(ng-repeat="type in metadata.node_types[schema]") {{type}}{{$last ? '' : ', '}}
    h2 Query Language
    p A basic <b>query</b> for nodes of the type, say <code>{{metadata.doc.type}}</code>, looks like this:</p>
    .code-listing(try-button="#query")
      pre {{metadata.doc.type}} [ ]
    p Similarly for other node types and node-type wildcards.
    p <b>Contstraints</b> on the node go between the square brackets [...]. Basic constraints on <b>attribute</b> values have the following forms:
    table.table.table-striped
      tr
        td <code><i>attribute</i> = '<i>value</i>'</code>
        td string comparison
      tr
        td <code><i>attribute</i> ~ '<i>reg-exp</i>'</code>
        td regular expression match
      tr
        td <code><i>attribute</i> &lt; number</code>
        td number comparison, same for &gt;, &lt;=, &gt;=, =
      tr
        td <code><i>attribute</i> in {'<i>value1</i>', '<i>value2</i>', ...}</code>
        td membership in an enumeration
    p For example:
    .code-listing(try-button="#query")
      pre {{metadata.doc.type}} [ {{metadata.doc.attr}} = '{{metadata.doc.value}}' ]
    p See the <span class="menu-item">Attributes</span> menu for the list of attributes for each node type.
      | Other <b>node properties</b>, such as number of sons, descendants, siblings, etc.
      | can be obtained using functions (see <span class="menu-item">Functions</span> Â» <span class="menu-item">Node Properties</span>).
      | In fact, <b>complex expressions</b> can be used on left and right hand side of the comparison operators in constraints; see the menus
      | <span class="menu-item">Operators</span> and <span class="menu-item">Funcions</span> for available arithmetic and string operators and functions.
    p The constraints can be combined using commas (<code>and</code>) or the logical operators <code>!</code> (not), <code>and</code>,
      | <code>or</code> (see also the <span class="menu-item"> Operators</span> menu). For example:
    .code-listing(try-button="#query")
      pre {{metadata.doc.type}} [ {{metadata.doc.attr}} = '{{metadata.doc.value}}', sons()=0 or lbrothers()+rbrothers()=0  ]
    p searches for any {{metadata.doc.type}} with {{metadata.doc.attr}}='{{metadata.doc.value}}' that is either a leaf node (has no sons) or an only child (has no left nor right siblings).
    p To introduce another node into the query, include it among the constrains and specify its <b>relation</b> to the existing node.
      | The <span class="menu-item">Relation</span> menu contains a list list of available relations.
      | Here a is an example using the relation 'child':
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} [
        |   {{metadata.doc.attr}} = '{{metadata.doc.value}}',
        |   child {{metadata.doc.type}} [ ]
        | ]
    p <b>Additional relations</b> between a pair of nodes can be specified by assigning <b>symbolic names</b>
      | to the query nodes. The names can be used also to refer to other node's attributes, e.g.
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} $a := [
        |   sibling {{metadata.doc.type}} [
        |     depth-first-follows $a,
        |     {{metadata.doc.attr}} = $a.{{metadata.doc.attr}}
        |   ]
        | ]
    p searches for any {{metadata.doc.type}} $a with a sibling {{metadata.doc.type}} having the same value of {{metadata.doc.attr}}
      | and following the node $a. We may also search for any {{metadata.doc.type}} with no such sibling, using a so called <b>subquery</b>
      | by quantifying the number of occurrences:
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} $a := [
        |   0x sibling {{metadata.doc.type}} [
        |     depth-first-follows $a,
        |     {{metadata.doc.attr}} = $a.{{metadata.doc.attr}}
        |   ]
        | ]
    p The symbol <code>0x</code>, stands for 'zero times'. Similarly, <code>1x</code> stands for 'exactly one', <code>3+x</code> for 'three and more',
      | <code>2-x</code> for 'at most two', or <code>1..10x</code> for 'one to ten'.
    h2 Output Filters
    p To count number of all matches of a query, append an output filter, e.g
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} [ ]
        | &gt;&gt; count()

    p Be careful when counting matches for queries with more than one node.
      | To count only distinct occurrences of a particular node, say <code>$a</code>, regardless of the other nodes
      | in the query, use these output filters instead:
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} $a := [ ]
        | &gt;&gt; distinct $a
        | &gt;&gt; count()
    p Output filters are used to extract data and generate a tabular output from a query.
      | For example, the following query lists all values of the attribute {{metadata.doc.attr}} and counts their occurrences:
    .code-listing(try-button="#query")
      pre
        | {{metadata.doc.type}} $a := [ ]
        | &gt;&gt; for $a.{{metadata.doc.attr}} give $1, count()
